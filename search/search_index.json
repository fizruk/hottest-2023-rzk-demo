{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Simplicial type theory in Rzk (demo)","text":"<p>This is a demo for the talk \u00abRzk proof assistant and simplicial HoTT formalization\u00bb at Homotopy Type Theory Electronic Seminar Talks (HoTTEST) on October 5, 2023 and contains a partial introduction to simplicial type theory in Rzk.</p> <p>Go to demo</p>"},{"location":"1-demo.rzk/","title":"Demo","text":""},{"location":"1-demo.rzk/#disclaimers","title":"Disclaimers","text":"<p>Info</p> <p>This demo is for the talk \u00abRzk proof assistant and simplicial HoTT formalization\u00bb at Homotopy Type Theory Electronic Seminar Talks (HoTTEST) on October 5, 2023 and contains a partial introduction to simplicial type theory in Rzk.</p> <p>Warning</p> <p>This demo relies on <code>rzk</code> version 0.6.6 and might not be up-to-date, as the proof assistant is in active development and breaking changes should be expected with further releases.</p>"},{"location":"1-demo.rzk/#setup","title":"Setup","text":"<p>To check the formalisations in this demo you can:</p> <ol> <li> <p>Have <code>rzk</code> installed locally    (the recommended way is to have VS Code extension for Rzk to handle it for you).    and running <code>rzk typecheck src/*.rzk.md</code> from the root of this project.</p> </li> <li> <p>Use an online playground at https://rzk-lang.github.io/rzk/v0.6.6/playground/    (and copy-paste code blocks there one by one)</p> </li> </ol>"},{"location":"1-demo.rzk/#formalisation-project-structure","title":"Formalisation project structure","text":"<p>Usually, formalisation projects in Rzk consist of multiple Rzk (or literate Rzk) files. For example, this demo project has the following structure:</p> <pre><code>hottest-2023-rzk-demo\n\u2502\n...\n\u2514\u2500\u2500 src\n    \u251c\u2500\u2500 1-demo.rzk.md\n    \u2514\u2500\u2500 2-exercises.rzk.md\n</code></pre> <p>The formalisations are located in the <code>src/</code> directory and contain just the two literate Rzk Markdown files. For another example,  rzk-lang/sHoTT has its formalisations further split into subdirectories:</p> <pre><code>sHoTT\n\u2502\n...\n\u2514\u2500\u2500 src\n    \u251c\u2500\u2500 STYLEGUIDE.md\n    \u251c\u2500\u2500 hott\n    \u2502   \u251c\u2500\u2500 00-common.rzk.md\n    \u2502   \u251c\u2500\u2500 01-paths.rzk.md\n    \u2502   \u251c\u2500\u2500 02-homotopies.rzk.md\n    \u2502   \u251c\u2500\u2500 03-equivalences.rzk.md\n    \u2502   \u251c\u2500\u2500 04-half-adjoint-equivalences.rzk.md\n    \u2502   \u251c\u2500\u2500 05-sigma.rzk.md\n    \u2502   \u251c\u2500\u2500 06-contractible.rzk.md\n    \u2502   \u251c\u2500\u2500 07-fibers.rzk.md\n    \u2502   \u251c\u2500\u2500 08-families-of-maps.rzk.md\n    \u2502   \u251c\u2500\u2500 09-propositions.rzk.md\n    \u2502   \u2514\u2500\u2500 10-trivial-fibrations.rzk.md\n    \u251c\u2500\u2500 index.md\n    \u2514\u2500\u2500 simplicial-hott\n        \u251c\u2500\u2500 03-simplicial-type-theory.rzk.md\n        \u251c\u2500\u2500 04-extension-types.rzk.md\n        \u251c\u2500\u2500 05-segal-types.rzk.md\n        \u251c\u2500\u2500 06-2cat-of-segal-types.rzk.md\n        \u251c\u2500\u2500 07-discrete.rzk.md\n        \u251c\u2500\u2500 08-covariant.rzk.md\n        \u251c\u2500\u2500 09-yoneda.rzk.md\n        \u251c\u2500\u2500 10-rezk-types.rzk.md\n        \u2514\u2500\u2500 12-cocartesian.rzk.md\n</code></pre>"},{"location":"1-demo.rzk/#running-rzk","title":"Running Rzk","text":"<p>To typecheck files, at the moment you have to run the following command in the terminal:</p> <pre><code>rzk typecheck\n</code></pre> <p>The list of files to check can be specified in <code>rzk.yaml</code> (as in this project), or listed explicitly as arguments to <code>rzk typecheck</code>:</p> <pre><code>rzk typecheck FILE-1 FILE-2 ... FILE-N\n</code></pre> <p>Warning</p> <p>It is important to pass formalisation files in the order you want them to be checked, as dependencies between files (in the form of imports) are not implemented yet.</p> <p>Tip</p> <p>Starting filenames with numbers (as in the examples above) helps automatically achieve the desired order when using wildcars (e.g. <code>rzk typecheck src/*.rzk.md</code>), although in a slightly inelegant way.</p>"},{"location":"1-demo.rzk/#literate-rzk","title":"Literate Rzk","text":"<p>If you are familiar with Markdown, then the recommended approach is to use literate Rzk Markdown, so that conventional Markdown rendering tools can be used to produce readable documentation from the formalisation files.</p> <p>For instance, this file is a literate Rzk Markdown file!</p>"},{"location":"1-demo.rzk/#syntax-overview","title":"Syntax overview","text":"<p>Each file in Rzk (or literate Rzk) must start with a declaration of the version/dialect used. We will use (the only supported) <code>rzk-1</code> dialect:</p> <pre><code>#lang rzk-1\n</code></pre> <p>The rest of the file contains primarily of <code>#define</code>-statements, each of which introduces a new definition into scope. For example, consider the following definition:</p> <pre><code>#define modus-ponens\n(A B : U)\n  : (A \u2192 B) \u2192 A \u2192 B\n  := \\ f x \u2192 f x\n</code></pre> <p>Going line by line, we have</p> <ul> <li><code>modus-ponens</code> as the name of a new definition</li> <li>two parameters \u2014 <code>A</code> and <code>B</code> (both of type <code>U</code>, meaning <code>A</code> and <code>B</code> are types<sup>1</sup>)</li> <li>declared type of <code>modus-ponens</code> is <code>(A \u2192 B) \u2192 A \u2192 B</code></li> <li>declared term (value) of <code>modus-ponens</code> is <code>\\ f x \u2192 f x</code></li> </ul> <p>Rzk typechecks the term against the declared type and, if no type errors found, remembers this definition for future use.</p>"},{"location":"1-demo.rzk/#unicode","title":"Unicode","text":"<p>Rzk supports both ASCII and Unicode versions of many syntactic constructions. We will use the following Unicode symbols:</p> <ul> <li><code>-&gt;</code> should be always replaced with <code>\u2192</code> (<code>\\to</code>)</li> <li><code>|-&gt;</code> should be always replaced with <code>\u21a6</code> (<code>\\mapsto</code>)</li> <li><code>===</code> should be always replaced with <code>\u2261</code> (<code>\\equiv</code>)</li> <li><code>&lt;=</code> should be always replaced with <code>\u2264</code> (<code>\\&lt;=</code>)</li> <li><code>/\\</code> should be always replaced with <code>\u2227</code> (<code>\\and</code>)</li> <li><code>\\/</code> should be always replaced with <code>\u2228</code> (<code>\\or</code>)</li> <li><code>0_2</code> should be always replaced with <code>0\u2082</code> (<code>0\\2</code>)</li> <li><code>1_2</code> should be always replaced with <code>1\u2082</code> (<code>1\\2</code>)</li> <li><code>I * J</code> should be always replaced with <code>I \u00d7 J</code> (<code>\\x</code> or <code>\\times</code>)</li> </ul> <p>We use ASCII versions for <code>TOP</code> and <code>BOT</code> since <code>\u22a4</code> and <code>\u22a5</code> do not read better in the code.</p>"},{"location":"1-demo.rzk/#dependent-types-with-rzk","title":"Dependent types with Rzk","text":"<p>We now proceed to look at the primitives in Rzk for working with dependent types.</p>"},{"location":"1-demo.rzk/#functions","title":"Functions","text":"<p>The type <code>(x : A) \u2192 B x</code> is the type of (dependent) functions with an argument of type <code>A</code> and, for each input <code>x</code>, the output type <code>B x</code>.</p> <p>As a simple example of a dependent function, consider the identity function:</p> <pre><code>#define identity\n  : (A : U) \u2192 (x : A) \u2192 A\n  := \\ A x \u2192 x\n</code></pre> <p>Since we are not using <code>x</code> in the type of <code>identity</code>, we can simply write the type of the argument, without providing its name:</p> <pre><code>#define identity\u2081\n  : (A : U) \u2192 A \u2192 A\n  := \\ A x \u2192 x\n</code></pre> <p>We can write this definition differently, by putting <code>(A : U)</code> into parameters (before <code>:</code>), and omitting it in the lambda abstraction:</p> <pre><code>#define identity\u2082\n(A : U)\n  : A \u2192 A\n  := \\ x \u2192 x\n</code></pre> <p>We could also move <code>x</code> into parameters as well, although this probably does not increase readability anymore:</p> <pre><code>#define identity\u2083\n(A : U)\n(x : A)\n  : A\n  := x\n</code></pre>"},{"location":"1-demo.rzk/#identity-type","title":"Identity type","text":"<p>For each type <code>(A : U)</code> and elements <code>(a b : A)</code> we have the identity type <code>a =_{A} b</code> of equalities (identities, paths) between <code>a</code> and <code>b</code>.</p> <pre><code>#define FunExt\n  : U\n  := (A : U) \u2192 (B : U)\n    \u2192 (f : A \u2192 B) \u2192 (g : A \u2192 B)\n    \u2192 ((x : A) \u2192 f x =_{B} g x)\n    \u2192 (f =_{A \u2192 B} g)\n</code></pre> <p>Rzk can figure out the type indices for identity types and we can omit them:</p> <pre><code>#define FunExt\u2081 : U\n  := (A : U) \u2192 (B : U)\n    \u2192 (f : A \u2192 B) \u2192 (g : A \u2192 B)\n    \u2192 ((x : A) \u2192 f x = g x)\n    \u2192 (f = g)\n</code></pre> <p>One way to prove an equality that exists for all types, is the proof by reflexivity. For example,</p> <pre><code>#define identity-x-eq-x\n(A : U)\n(x : A)\n  : (identity A x = x)\n  := refl_{x : A}\n</code></pre> <p>Indeed, <code>identity A x</code> computes to <code>x</code>, and is therefore definitionally (computatioally) equal to it allowing for the use of <code>refl_{x : A}</code>. Again, Rzk can figure out indices accepting <code>refl_{x}</code> or just <code>refl</code>.</p> <p>Using a value of an identity type requires the path induction, which we can define via the built-in version of it, <code>idJ</code>:</p> <pre><code>#define ind-path\n(A : U)\n(a : A)\n(C : (x : A) -&gt; (a = x) -&gt; U)\n(d : C a refl)\n(b : A)\n  : (p : a = b) \u2192 C b p\n  := \\ p \u2192 idJ (A, a, C, d, b, p)\n</code></pre> <p>As an example, we can show symmetry for equality types by induction on the argument of type <code>a = b</code>:</p> <pre><code>#define inverse\n(A : U)\n(a b : A)\n  : (a = b) \u2192 (b = a)\n  := ind-path A a (\\ x _ \u2192 x = a) refl b\n</code></pre>"},{"location":"1-demo.rzk/#dependent-sums","title":"Dependent sums","text":"<p>The type <code>\u03a3 (x : A), B x</code> is a type of (dependent) pairs where the first component (named <code>x</code> here) is of type <code>A</code>, and the second component is of type <code>B x</code>.</p> <p>For example, preimages (fibers) of functions can be defined using <code>\u03a3</code>-types:</p> <pre><code>#define preimage\n(A B : U)\n(f : A \u2192 B)\n(y : B)\n  : U\n  := \u03a3 (x : A), (f x = y)\n</code></pre> <pre><code>#define product\n( A B : U)\n  : U\n  := \u03a3 (_ : A), B\n</code></pre>"},{"location":"1-demo.rzk/#hott-with-rzk","title":"HoTT with Rzk","text":"<p>In HoTT (and in Rzk), the identity type is not always a proposition and <code>refl</code> might not be the only proof of equality!</p> Type Error!<pre><code>#define does-not-typecheck\n(A : U)\n(x : A)\n(p : x = x)\n  : p = refl\n  := refl -- path induction on p also cannot work!\n</code></pre> <p>Info</p> <p>At the moment Rzk does not have support for higher inductive types, but it is expected in the future.</p>"},{"location":"1-demo.rzk/#simplicial-types-with-rzk","title":"Simplicial types with Rzk","text":"<p>Following Riehl\u2013Shulman's paper<sup>2</sup>, Rzk has cube and tope layers<sup>3</sup>. These provide the ability to specify (higher) diagram schemas.</p> <p>For the purposes of his demo, we will only care about the directed interval cube <code>2</code>, 2-dimensional directed cube <code>(2 \u00d7 2)</code>, and 3-dimensional directed cube <code>(2 \u00d7 2 \u00d7 2)</code>.</p> <p>A cube may have points in it, and the directed interval <code>2</code> has two known points <code>0\u2082 : 2</code> and <code>1\u2082 : 2</code>.</p>"},{"location":"1-demo.rzk/#tope-layer","title":"Tope layer","text":"<p>Tope layer adds logical constraints on the points in a cube, \"carving out\" a shape inside a space. There is a handful of ways to specify topes:</p> <ul> <li><code>TOP</code> selects all points (provides no constraints)</li> <li><code>BOT</code> selects no points (producing an empty shape)</li> <li><code>(\u03c6 \u2227 \u03c8)</code> selects all points that satisfy both <code>\u03c6</code> and <code>\u03c8</code></li> <li><code>(\u03c6 \u2228 \u03c8)</code> selects all points that satisfy <code>\u03c6</code> or <code>\u03c8</code> (or both)</li> <li><code>(t \u2261 s)</code> selects all points such that <code>t</code> is equal to <code>s</code></li> <li><code>(t \u2264 s)</code> selects all points such that <code>t \u2264 s</code> (only when both <code>t</code> and <code>s</code> are in <code>2</code>)</li> </ul> <p>Mostly for technical reasons, we define shapes as mappings from cubes into the <code>TOPE</code> universe. For example, here is a shape that carves a (directed) triangle out of a (directed) square:</p> <p> \u2022 \u2022 \u2022 </p> <pre><code>#define \u0394\u00b9\n  : 2 \u2192 TOPE\n  := \\ _ \u2192 TOP\n#define \u0394\u00b2\n  : (2 \u00d7 2) \u2192 TOPE\n  := \\ (t, s) \u2192 (s \u2264 t)\n</code></pre> <p>For another example, here is a 3-dimensional simplex:</p> <p> \u2022 \u2022 \u2022 \u2022 </p> <pre><code>#define \u0394\u00b3\n  : (2 \u00d7 2 \u00d7 2) \u2192 TOPE\n  := \\ ((t\u2081, t\u2082), t\u2083) \u2192 (t\u2083 \u2264 t\u2082) \u2227 (t\u2082 \u2264 t\u2081)\n</code></pre> <p>Yet another example would be the horn shape that only takes two edges of a square:</p> <p> \u2022 \u2022 \u2022 </p> <pre><code>#define \u039b\n  : (2 \u00d7 2) \u2192 TOPE\n  := \\ (t, s) \u2192 (s \u2261 0\u2082) \u2228 (t \u2261 1\u2082)\n</code></pre> <p>We could refine this definition by specifying that it is a subshape of <code>\u0394\u00b2</code>:</p> <pre><code>#define \u039b'\n  : ( (t, s) : 2 \u00d7 2 | \u0394\u00b2 (t, s) ) \u2192 TOPE\n  := \\ (t, s) \u2192 (s \u2261 0\u2082) \u2228 (t \u2261 1\u2082)\n</code></pre> <p>Since shapes have the information about the cube in their types, Rzk provides an implicit coercion, allowing shorter definitions:</p> <pre><code>#define \u039b''\n  : \u0394\u00b2 \u2192 TOPE\n  := \\ (t, s) \u2192 (s \u2261 0\u2082) \u2228 (t \u2261 1\u2082)\n</code></pre> <p>Note</p> <p>This more precise type expresses a restriction on the definition of <code>\u039b''</code>, but, perhaps counterintuitively, not on the input points! With this type, Rzk additionally checks that <code>(s \u2261 0) \u2228 (t \u2261 1)</code> implies <code>\u0394\u00b2 (t, s)</code> for all <code>t</code>, <code>s</code>. However, we can still apply <code>\u039b''</code> to all points in the cube <code>(2 \u00d7 2)</code>.</p> <p>Mapping from a shape into a type, effectively selects a concrete diagram in it. We can select a subdiagram, simply by restricting to a subshape:</p> <p> f f f f f f f f f f f </p> <pre><code>#define horn-restriction\n(A : U)\n  : (f : \u0394\u00b2 \u2192 A) \u2192 (\u039b \u2192 A)\n  := \\ f t \u2192 f t\n</code></pre> <p>To construct diagrams from parts, we can use <code>recOR</code> by specifying values for several shapes. Rzk will be checking that provided values agree (definitionally) on the intersections of these shapes.</p> <p>For example, given a triangle, we can construct a square:</p> <p> recOR (\u03c0\u2081 x\u2082 \u2264 \u03c0\u2082 x\u2082 \u21a6 triang\u2026 recOR (\u03c0\u2081 x\u2082 \u2264 \u03c0\u2082 x\u2082 \u21a6 triang\u2026 recOR (\u03c0\u2081 x\u2082 \u2264 \u03c0\u2082 x\u2082 \u21a6 triang\u2026 recOR (\u03c0\u2081 x\u2082 \u2264 \u03c0\u2082 x\u2082 \u21a6 triang\u2026 recOR (\u03c0\u2081 x\u2082 \u2264 \u03c0\u2082 x\u2082 \u21a6 triang\u2026 recOR (\u03c0\u2081 x\u2082 \u2264 \u03c0\u2082 x\u2082 \u21a6 triang\u2026 recOR (\u03c0\u2081 x\u2082 \u2264 \u03c0\u2082 x\u2082 \u21a6 triang\u2026 \u2022 \u2022 \u2022 \u2022 </p> <pre><code>#define unfolding-square\n(A : U)\n(triangle : \u0394\u00b2 \u2192 A)\n  : (2 \u00d7 2) \u2192 A\n  :=\n    \\ (t, s) \u2192\nrecOR\n      ( t \u2264 s \u21a6 triangle (s , t) ,\n        s \u2264 t \u21a6 triangle (t , s))\n</code></pre>"},{"location":"1-demo.rzk/#extension-types-with-rzk","title":"Extension types with Rzk","text":"<p>Mapping from a shape into a type, we get a diagram. To fix some parts of the diagram, we can specify refinements \u2014 for each subshape we want to fix, we provide an explicit term of the proper type.</p> <p>For example, taking a diagram in <code>A</code> correspoding to the directed interval <code>2</code> and fixing the endpoints, we get the type of all arrows between two given points in <code>A</code>:</p> <p> x y </p> <pre><code>#define hom\n(A : U)\n(x y : A)\n  : U\n  := (t : 2) \u2192\n    A [ t \u2261 0\u2082 \u21a6 x\n      , t \u2261 1\u2082 \u21a6 y ]\n</code></pre> <p>Note that this is different from the following type, since in <code>hom</code> endpoints are <code>x</code> and <code>y</code> definitionally, where as <code>pseudo-hom</code> carries proofs of equality and requires extra bookkeeping:</p> <pre><code>#define pseudo-hom\n(A : U)\n(x y : A)\n  : U\n  := \u03a3 (f : 2 \u2192 A), product (f 0\u2082 = x) (f 1\u2082 = y)\n</code></pre> <p>Another common example of an extension type would be the <code>hom2</code> type of composites of arrows:</p> <p> f f g g x y z </p> <pre><code>#define hom2\n(A : U)\n(x y z : A)\n(f : hom A x y)\n(g : hom A y z)\n  : U\n  := ((t, s) : \u0394\u00b2) \u2192\n    A [ s \u2261 0\u2082 \u21a6 f t\n      , t \u2261 1\u2082 \u21a6 g s ]\n</code></pre>"},{"location":"1-demo.rzk/#equivalences","title":"Equivalences","text":"<pre><code>#def is-equiv\n( A B : U)\n( f : A \u2192 B)\n  : U\n  := product\n(\u03a3 (s : B \u2192 A) , (b : B) \u2192 (f (s b) = b))\n(\u03a3 (r : B \u2192 A) , (a : A) \u2192 (r (f a) = a))\n#def Equiv\n( A B : U)\n  : U\n  := \u03a3 (f : A \u2192 B) , (is-equiv A B f)\n</code></pre>"},{"location":"1-demo.rzk/#cofibration-composition","title":"Cofibration composition","text":"<p>A useful theorem about extension types says that any extension type is equivalent to an extension of its restriction.</p> RS17, Theorem 4.4<pre><code>#def cofibration-composition\n( I : CUBE)\n( \u03c7 : I \u2192 TOPE)\n( \u03c8 : \u03c7 \u2192 TOPE)\n( \u03d5 : \u03c8 \u2192 TOPE)\n( X : \u03c7 \u2192 U)\n( a : (t : \u03d5) \u2192 X t)\n  : Equiv\n( (t : \u03c7) \u2192 X t [\u03d5 t \u21a6 a t])\n( \u03a3 ( f : (t : \u03c8) \u2192 X t [\u03d5 t \u21a6 a t]) ,\n( (t : \u03c7) \u2192 X t [\u03c8 t \u21a6 f t]))\n  :=\n    ( \\ h \u2192 (\\ t \u2192 h t , \\ t \u2192 h t) ,\n      ( ( \\ (_f , g) t \u2192 g t , \\ h \u2192 refl) ,\n        ( ( \\ (_f , g) t \u2192 g t , \\ h \u2192 refl))))\n</code></pre> <p> <p></p> <ol> <li> <p>technically, in Rzk currently <code>U</code> contains also <code>CUBE</code>, <code>TOPE</code> universes, and itself!\u00a0\u21a9</p> </li> <li> <p>Emily Riehl &amp; Michael Shulman. A type theory for synthetic \u221e-categories. Higher Structures 1(1), 147-224. 2017. https://arxiv.org/abs/1705.07442 \u21a9</p> </li> <li> <p>Instead of builtin layers, Rzk uses <code>CUBE</code> and <code>TOPE</code> universes to separate them from the types.\u00a0\u21a9</p> </li> </ol>"}]}